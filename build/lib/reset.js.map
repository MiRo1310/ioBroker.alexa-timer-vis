{
  "version": 3,
  "sources": ["../../src/lib/reset.ts"],
  "sourcesContent": ["import type AlexaTimerVis from '../main';\nimport { useStore } from '../store/store';\nimport { errorLogger } from './logging';\nimport type { Timer, TimerSelector } from '../types/types';\n\nimport { timerObject } from '../config/timer-data';\nimport { writeState } from './write-state';\n\nexport const resetValues = async (timer: Timer, index: TimerSelector): Promise<void> => {\n    const { _this, getAlexaTimerVisInstance, valHourForZero, valMinuteForZero, valSecondForZero } = useStore();\n\n    try {\n        timerObject.timerActive.timer[index as keyof typeof timerObject.timerActive.timer] = false; // Timer auf false setzen falls Zeit abgelaufen ist, ansonsten steht er schon auf false\n        _this.log.debug(JSON.stringify(timerObject.timerActive));\n        timer.hour = valHourForZero || '';\n        timer.minute = valMinuteForZero || '';\n        timer.second = valSecondForZero || '';\n        timer.stringTimer = '00:00:00 h';\n        timer.stringTimer2 = '';\n        timer.voiceInputAsSeconds = 0;\n        timer.remainingTimeInSeconds = 0;\n        timer.index = undefined;\n        timer.name = '';\n        timer.alexaTimerName = '';\n        timer.startTimeString = '00:00:00';\n        timer.endTimeString = '00:00:00';\n        timer.inputDevice = '';\n        timer.timerInterval = 0;\n        timer.lengthTimer = '';\n        timer.percent = 0;\n        timer.percent2 = 0;\n        timer.extendOrShortenTimer = false;\n        timer.id = '';\n        timer.serialNumber = '';\n        timer.inputString = '';\n        timer.startTimeNumber = 0;\n        timer.endTimeNumber = 0;\n\n        await _this.setObject(getAlexaTimerVisInstance() + index, {\n            type: 'device',\n            common: { name: `` },\n            native: {},\n        });\n    } catch (e: any) {\n        errorLogger('Error in resetValues', e, _this);\n    }\n};\n\nexport function resetAllTimerValuesAndState(_this: AlexaTimerVis): void {\n    Object.keys(timerObject.timer).forEach(el => {\n        resetValues(timerObject.timer[el as keyof typeof timerObject.timer], el as TimerSelector).catch(e => {\n            errorLogger('Error in resetAllTimerValuesAndState', e, _this);\n        });\n\n        writeState({ reset: true }).catch(e => {\n            errorLogger('Error in resetAllTimerValuesAndState', e, _this);\n        });\n    });\n    _this.setStateChanged('all_Timer.alive', false, true);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAAyB;AACzB,qBAA4B;AAG5B,wBAA4B;AAC5B,yBAA2B;AAEpB,MAAM,cAAc,OAAO,OAAc,UAAwC;AACpF,QAAM,EAAE,OAAO,0BAA0B,gBAAgB,kBAAkB,iBAAiB,QAAI,uBAAS;AAEzG,MAAI;AACA,kCAAY,YAAY,MAAM,KAAmD,IAAI;AACrF,UAAM,IAAI,MAAM,KAAK,UAAU,8BAAY,WAAW,CAAC;AACvD,UAAM,OAAO,kBAAkB;AAC/B,UAAM,SAAS,oBAAoB;AACnC,UAAM,SAAS,oBAAoB;AACnC,UAAM,cAAc;AACpB,UAAM,eAAe;AACrB,UAAM,sBAAsB;AAC5B,UAAM,yBAAyB;AAC/B,UAAM,QAAQ;AACd,UAAM,OAAO;AACb,UAAM,iBAAiB;AACvB,UAAM,kBAAkB;AACxB,UAAM,gBAAgB;AACtB,UAAM,cAAc;AACpB,UAAM,gBAAgB;AACtB,UAAM,cAAc;AACpB,UAAM,UAAU;AAChB,UAAM,WAAW;AACjB,UAAM,uBAAuB;AAC7B,UAAM,KAAK;AACX,UAAM,eAAe;AACrB,UAAM,cAAc;AACpB,UAAM,kBAAkB;AACxB,UAAM,gBAAgB;AAEtB,UAAM,MAAM,UAAU,yBAAyB,IAAI,OAAO;AAAA,MACtD,MAAM;AAAA,MACN,QAAQ,EAAE,MAAM,GAAG;AAAA,MACnB,QAAQ,CAAC;AAAA,IACb,CAAC;AAAA,EACL,SAAS,GAAQ;AACb,oCAAY,wBAAwB,GAAG,KAAK;AAAA,EAChD;AACJ;AAEO,SAAS,4BAA4B,OAA4B;AACpE,SAAO,KAAK,8BAAY,KAAK,EAAE,QAAQ,QAAM;AACzC,gBAAY,8BAAY,MAAM,EAAoC,GAAG,EAAmB,EAAE,MAAM,OAAK;AACjG,sCAAY,wCAAwC,GAAG,KAAK;AAAA,IAChE,CAAC;AAED,uCAAW,EAAE,OAAO,KAAK,CAAC,EAAE,MAAM,OAAK;AACnC,sCAAY,wCAAwC,GAAG,KAAK;AAAA,IAChE,CAAC;AAAA,EACL,CAAC;AACD,QAAM,gBAAgB,mBAAmB,OAAO,IAAI;AACxD;",
  "names": []
}
