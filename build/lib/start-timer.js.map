{
  "version": 3,
  "sources": ["../../src/lib/start-timer.ts"],
  "sourcesContent": ["import type { AlexaJson, TimerIndex } from '@/types/types';\nimport { timerObject } from '@/config/timer-data';\nimport store from '@/store/store';\nimport { isString, timeToString } from '@/lib/global';\nimport { interval } from '@/lib/interval';\nimport { errorLogger } from '@/lib/logging';\n\nconst isMoreThanAMinute = (sec: number): boolean => sec > 60;\n\nexport const startTimer = async (sec: number, name: string): Promise<void> => {\n    try {\n        const timerIndex = getAvailableTimerIndex();\n        timerObject.timerActive.timer[timerIndex] = true;\n\n        const alexaJson = await getParsedAlexaJson();\n        if (!alexaJson) {\n            return;\n        }\n\n        const creationTime = alexaJson.creationTime;\n        const startTimeString = timeToString(creationTime);\n        const timerMilliseconds = sec * 1000;\n        const endTimeNumber = creationTime + timerMilliseconds;\n        const endTimeString = timeToString(endTimeNumber);\n        const timer = timerObject.timer[timerIndex];\n        await timer.init({ timerIndex, creationTime, startTimeString, endTimeNumber, endTimeString });\n\n        if (isMoreThanAMinute(sec)) {\n            interval(sec, name, timer, store.intervalMore60 * 1000, false);\n            return;\n        }\n\n        timerObject.timer[timerIndex].setInterval(store.intervalLess60 * 1000);\n\n        interval(sec, name, timer, store.intervalLess60 * 1000, true);\n    } catch (e: any) {\n        errorLogger('Error in startTimer', e);\n    }\n};\n\nexport async function getParsedAlexaJson(): Promise<AlexaJson | undefined> {\n    const instance = store.getAlexaInstanceObject().instance;\n    const jsonAlexa = await store.adapter.getForeignStateAsync(`alexa2.${instance}.History.json`);\n    try {\n        if (isString(jsonAlexa?.val)) {\n            return JSON.parse(jsonAlexa.val);\n        }\n    } catch (e) {\n        errorLogger('Error in getParsedAlexaJson', e);\n    }\n}\n\nexport function getAvailableTimerIndex(): TimerIndex {\n    const keys = Object.keys(timerObject.timerActive.timer);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (!timerObject.timerActive.timer[key]) {\n            return key;\n        }\n    }\n    return `timer${keys.length + 1}`;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,wBAA4B;AAC5B,mBAAkB;AAClB,oBAAuC;AACvC,sBAAyB;AACzB,qBAA4B;AAE5B,MAAM,oBAAoB,CAAC,QAAyB,MAAM;AAEnD,MAAM,aAAa,OAAO,KAAa,SAAgC;AAC1E,MAAI;AACA,UAAM,aAAa,uBAAuB;AAC1C,kCAAY,YAAY,MAAM,UAAU,IAAI;AAE5C,UAAM,YAAY,MAAM,mBAAmB;AAC3C,QAAI,CAAC,WAAW;AACZ;AAAA,IACJ;AAEA,UAAM,eAAe,UAAU;AAC/B,UAAM,sBAAkB,4BAAa,YAAY;AACjD,UAAM,oBAAoB,MAAM;AAChC,UAAM,gBAAgB,eAAe;AACrC,UAAM,oBAAgB,4BAAa,aAAa;AAChD,UAAM,QAAQ,8BAAY,MAAM,UAAU;AAC1C,UAAM,MAAM,KAAK,EAAE,YAAY,cAAc,iBAAiB,eAAe,cAAc,CAAC;AAE5F,QAAI,kBAAkB,GAAG,GAAG;AACxB,oCAAS,KAAK,MAAM,OAAO,aAAAA,QAAM,iBAAiB,KAAM,KAAK;AAC7D;AAAA,IACJ;AAEA,kCAAY,MAAM,UAAU,EAAE,YAAY,aAAAA,QAAM,iBAAiB,GAAI;AAErE,kCAAS,KAAK,MAAM,OAAO,aAAAA,QAAM,iBAAiB,KAAM,IAAI;AAAA,EAChE,SAAS,GAAQ;AACb,oCAAY,uBAAuB,CAAC;AAAA,EACxC;AACJ;AAEA,eAAsB,qBAAqD;AACvE,QAAM,WAAW,aAAAA,QAAM,uBAAuB,EAAE;AAChD,QAAM,YAAY,MAAM,aAAAA,QAAM,QAAQ,qBAAqB,UAAU,QAAQ,eAAe;AAC5F,MAAI;AACA,YAAI,wBAAS,uCAAW,GAAG,GAAG;AAC1B,aAAO,KAAK,MAAM,UAAU,GAAG;AAAA,IACnC;AAAA,EACJ,SAAS,GAAG;AACR,oCAAY,+BAA+B,CAAC;AAAA,EAChD;AACJ;AAEO,SAAS,yBAAqC;AACjD,QAAM,OAAO,OAAO,KAAK,8BAAY,YAAY,KAAK;AACtD,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,UAAM,MAAM,KAAK,CAAC;AAElB,QAAI,CAAC,8BAAY,YAAY,MAAM,GAAG,GAAG;AACrC,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO,QAAQ,KAAK,SAAS,CAAC;AAClC;",
  "names": ["store"]
}
