{
  "version": 3,
  "sources": ["../../src/lib/start-timer.ts"],
  "sourcesContent": ["import type { Store, TimerSelector } from '../types/types';\nimport { timerObject } from '../config/timer-data';\nimport { useStore } from '../store/store';\nimport { isString, timeToString } from './global';\nimport { getInputDevice } from './get-input-device';\nimport { interval } from './interval';\nimport type AlexaTimerVis from '../main';\nimport { registerIdToGetTimerName } from './timer-name';\nimport { errorLogger } from './logging';\n\nexport const startTimer = async (sec: number, name: string, inputString: string): Promise<void> => {\n    const store = useStore();\n    const _this = store._this;\n    try {\n        const timerSelector = selectAvailableTimer(_this);\n\n        await getInputDevice(timerObject.timer[timerSelector as keyof typeof timerObject.timer]);\n        await registerIdToGetTimerName(timerSelector);\n\n        const jsonAlexa = await _this.getForeignStateAsync(`alexa2.0.History.json`);\n        const startTimer: number = getStartTimerValue(jsonAlexa);\n        const start_Time = timeToString(startTimer);\n        const timerMilliseconds = sec * 1000;\n        const endTimeMilliseconds = startTimer + timerMilliseconds;\n        const endTimeString = timeToString(endTimeMilliseconds);\n\n        saveToObject(timerSelector, endTimeMilliseconds, endTimeString, start_Time, startTimer);\n\n        await setDeviceNameInStateName(timerSelector, _this, store);\n\n        const timer = timerObject.timer[timerSelector as keyof typeof timerObject.timer];\n\n        if (isMoreThanAMinute(sec)) {\n            interval(sec, timerSelector, inputString, name, timer, store.intervalMore60 * 1000, false);\n            return;\n        }\n\n        timerObject.timer.timer1.timerInterval = store.intervalLess60 * 1000;\n\n        interval(sec, timerSelector, inputString, name, timer, store.intervalLess60 * 1000, true);\n    } catch (e: any) {\n        errorLogger('Error in startTimer', e, _this);\n    }\n};\n\nfunction getStartTimerValue(jsonAlexa: ioBroker.State | null | undefined): number {\n    if (isString(jsonAlexa?.val)) {\n        return JSON.parse(jsonAlexa.val).creationTime;\n    }\n    return new Date().getTime();\n}\n\nfunction selectAvailableTimer(_this: AlexaTimerVis): TimerSelector {\n    for (let i = 0; i < Object.keys(timerObject.timerActive.timer).length; i++) {\n        const key = Object.keys(timerObject.timerActive.timer)[i] as keyof typeof timerObject.timerActive.timer;\n\n        if (!timerObject.timerActive.timer[key]) {\n            timerObject.timerActive.timer[key] = true;\n            return key;\n        }\n    }\n}\n\nasync function setDeviceNameInStateName(\n    timerBlock: string | undefined,\n    _this: AlexaTimerVis,\n    store: Store,\n): Promise<void> {\n    if (isString(timerBlock)) {\n        await _this.setObjectAsync(`alexa-timer-vis.0.${timerBlock}`, {\n            type: 'device',\n            common: { name: `${store.deviceName}` },\n            native: {},\n        });\n    }\n}\n\nfunction isMoreThanAMinute(sec: number): boolean {\n    return sec > 60;\n}\n\nfunction saveToObject(\n    timerBlock: TimerSelector,\n    endTimeNumber: number,\n    endTimeString: string,\n    start_Time: string,\n    startTimeNumber: number,\n): void {\n    if (timerBlock) {\n        timerObject.timer[timerBlock].endTimeNumber = endTimeNumber;\n        timerObject.timer[timerBlock].endTimeString = endTimeString;\n        timerObject.timer[timerBlock].startTimeString = start_Time;\n        timerObject.timer[timerBlock].startTimeNumber = startTimeNumber;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,wBAA4B;AAC5B,mBAAyB;AACzB,oBAAuC;AACvC,8BAA+B;AAC/B,sBAAyB;AAEzB,wBAAyC;AACzC,qBAA4B;AAErB,MAAM,aAAa,OAAO,KAAa,MAAc,gBAAuC;AAC/F,QAAM,YAAQ,uBAAS;AACvB,QAAM,QAAQ,MAAM;AACpB,MAAI;AACA,UAAM,gBAAgB,qBAAqB,KAAK;AAEhD,cAAM,wCAAe,8BAAY,MAAM,aAA+C,CAAC;AACvF,cAAM,4CAAyB,aAAa;AAE5C,UAAM,YAAY,MAAM,MAAM,qBAAqB,uBAAuB;AAC1E,UAAMA,cAAqB,mBAAmB,SAAS;AACvD,UAAM,iBAAa,4BAAaA,WAAU;AAC1C,UAAM,oBAAoB,MAAM;AAChC,UAAM,sBAAsBA,cAAa;AACzC,UAAM,oBAAgB,4BAAa,mBAAmB;AAEtD,iBAAa,eAAe,qBAAqB,eAAe,YAAYA,WAAU;AAEtF,UAAM,yBAAyB,eAAe,OAAO,KAAK;AAE1D,UAAM,QAAQ,8BAAY,MAAM,aAA+C;AAE/E,QAAI,kBAAkB,GAAG,GAAG;AACxB,oCAAS,KAAK,eAAe,aAAa,MAAM,OAAO,MAAM,iBAAiB,KAAM,KAAK;AACzF;AAAA,IACJ;AAEA,kCAAY,MAAM,OAAO,gBAAgB,MAAM,iBAAiB;AAEhE,kCAAS,KAAK,eAAe,aAAa,MAAM,OAAO,MAAM,iBAAiB,KAAM,IAAI;AAAA,EAC5F,SAAS,GAAQ;AACb,oCAAY,uBAAuB,GAAG,KAAK;AAAA,EAC/C;AACJ;AAEA,SAAS,mBAAmB,WAAsD;AAC9E,UAAI,wBAAS,uCAAW,GAAG,GAAG;AAC1B,WAAO,KAAK,MAAM,UAAU,GAAG,EAAE;AAAA,EACrC;AACA,UAAO,oBAAI,KAAK,GAAE,QAAQ;AAC9B;AAEA,SAAS,qBAAqB,OAAqC;AAC/D,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK,8BAAY,YAAY,KAAK,EAAE,QAAQ,KAAK;AACxE,UAAM,MAAM,OAAO,KAAK,8BAAY,YAAY,KAAK,EAAE,CAAC;AAExD,QAAI,CAAC,8BAAY,YAAY,MAAM,GAAG,GAAG;AACrC,oCAAY,YAAY,MAAM,GAAG,IAAI;AACrC,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAEA,eAAe,yBACX,YACA,OACA,OACa;AACb,UAAI,wBAAS,UAAU,GAAG;AACtB,UAAM,MAAM,eAAe,qBAAqB,UAAU,IAAI;AAAA,MAC1D,MAAM;AAAA,MACN,QAAQ,EAAE,MAAM,GAAG,MAAM,UAAU,GAAG;AAAA,MACtC,QAAQ,CAAC;AAAA,IACb,CAAC;AAAA,EACL;AACJ;AAEA,SAAS,kBAAkB,KAAsB;AAC7C,SAAO,MAAM;AACjB;AAEA,SAAS,aACL,YACA,eACA,eACA,YACA,iBACI;AACJ,MAAI,YAAY;AACZ,kCAAY,MAAM,UAAU,EAAE,gBAAgB;AAC9C,kCAAY,MAAM,UAAU,EAAE,gBAAgB;AAC9C,kCAAY,MAAM,UAAU,EAAE,kBAAkB;AAChD,kCAAY,MAAM,UAAU,EAAE,kBAAkB;AAAA,EACpD;AACJ;",
  "names": ["startTimer"]
}
