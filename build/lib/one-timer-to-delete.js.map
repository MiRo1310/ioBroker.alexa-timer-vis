{
  "version": 3,
  "sources": ["../../src/lib/one-timer-to-delete.ts"],
  "sourcesContent": ["import { timerObject } from '../config/timer-data';\nimport { sortArray } from './global';\n\nexport const oneOfMultiTimerDelete = (input: string, timeSec: number, name: string, inputDevice: string): void => {\n    const separateInput = input.slice(input.indexOf(',') + 2, input.length);\n\n    const separateInputArray = separateInput.split(' ');\n    let timerNumber;\n\n    // \u00DCber pr\u00FCfen ob die Antwort eine Zahl ist oder ein Name\n    for (const element of separateInputArray) {\n        if (timerObject.assignment[element as keyof typeof timerObject.assignment] > 0) {\n            // Es handelt sich um eine Zahl die im Array gefunden wurde\n\n            timerNumber = timerObject.assignment[element as keyof typeof timerObject.assignment];\n        } else {\n            name = separateInput.replace('timer', '').trim();\n            timerNumber = 0;\n        }\n    }\n\n    let sortable = [];\n    for (const timerName in timerObject.timer) {\n        const timer = timerObject.timer[timerName];\n        sortable.push([\n            timerName,\n            timer.getVoiceInputAsSeconds(),\n            timer.getRemainingTimeInSeconds(),\n            timer.getName(),\n            timer.getInputDevice(),\n        ]);\n    }\n\n    sortable = sortArray(sortable); // Das Array in dem die Timer sind nach der Gr\u00F6\u00DFe sortieren und dann das entsprechende Element stoppen\n\n    let i = 1;\n\n    for (const element of sortable) {\n        if (element[1] == timeSec && timerNumber == i) {\n            // Auf Zeit \u00FCberpr\u00FCfen\n            timerObject.timerActive.timer[element[0]] = false;\n            break;\n        } else if (element[3] == name && timerNumber == i) {\n            // Auf Name \u00FCberpr\u00FCfen\n            timerObject.timerActive.timer[element[0]] = false;\n            break;\n        } else if (element[3] == name && timerNumber == 0) {\n            // Auf Name \u00FCberpr\u00FCfen, wenn der Name in der Antwort vor kam\n            timerObject.timerActive.timer[element[0]] = false;\n            break;\n        } else if (element[4] == inputDevice && timerNumber == i) {\n            // Auf Device \u00FCberpr\u00FCfen\n            timerObject.timerActive.timer[element[0]] = false;\n            break;\n        } else if (inputDevice == '' && timeSec == 0 && name == '' && timerNumber == i) {\n            // Wenn kein Angaben vor liegen\n            timerObject.timerActive.timer[element[0]] = false;\n            break;\n        } else {\n            i++;\n        }\n    }\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAA4B;AAC5B,oBAA0B;AAEnB,MAAM,wBAAwB,CAAC,OAAe,SAAiB,MAAc,gBAA8B;AAC9G,QAAM,gBAAgB,MAAM,MAAM,MAAM,QAAQ,GAAG,IAAI,GAAG,MAAM,MAAM;AAEtE,QAAM,qBAAqB,cAAc,MAAM,GAAG;AAClD,MAAI;AAGJ,aAAW,WAAW,oBAAoB;AACtC,QAAI,8BAAY,WAAW,OAA8C,IAAI,GAAG;AAG5E,oBAAc,8BAAY,WAAW,OAA8C;AAAA,IACvF,OAAO;AACH,aAAO,cAAc,QAAQ,SAAS,EAAE,EAAE,KAAK;AAC/C,oBAAc;AAAA,IAClB;AAAA,EACJ;AAEA,MAAI,WAAW,CAAC;AAChB,aAAW,aAAa,8BAAY,OAAO;AACvC,UAAM,QAAQ,8BAAY,MAAM,SAAS;AACzC,aAAS,KAAK;AAAA,MACV;AAAA,MACA,MAAM,uBAAuB;AAAA,MAC7B,MAAM,0BAA0B;AAAA,MAChC,MAAM,QAAQ;AAAA,MACd,MAAM,eAAe;AAAA,IACzB,CAAC;AAAA,EACL;AAEA,iBAAW,yBAAU,QAAQ;AAE7B,MAAI,IAAI;AAER,aAAW,WAAW,UAAU;AAC5B,QAAI,QAAQ,CAAC,KAAK,WAAW,eAAe,GAAG;AAE3C,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAAC,IAAI;AAC5C;AAAA,IACJ,WAAW,QAAQ,CAAC,KAAK,QAAQ,eAAe,GAAG;AAE/C,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAAC,IAAI;AAC5C;AAAA,IACJ,WAAW,QAAQ,CAAC,KAAK,QAAQ,eAAe,GAAG;AAE/C,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAAC,IAAI;AAC5C;AAAA,IACJ,WAAW,QAAQ,CAAC,KAAK,eAAe,eAAe,GAAG;AAEtD,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAAC,IAAI;AAC5C;AAAA,IACJ,WAAW,eAAe,MAAM,WAAW,KAAK,QAAQ,MAAM,eAAe,GAAG;AAE5E,oCAAY,YAAY,MAAM,QAAQ,CAAC,CAAC,IAAI;AAC5C;AAAA,IACJ,OAAO;AACH;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
