{
  "version": 3,
  "sources": ["../../src/app/write-state.ts"],
  "sourcesContent": ["import { timerObject } from '@/config/timer-data';\nimport { errorLogger } from '@/lib/logging';\nimport store from '@/store/store';\nimport { getTimerByIndex } from '@/app/timer';\n\nexport const writeStatesByTimerIndex = async (timerIndex: string, reset: boolean): Promise<void> => {\n    const adapter = store.adapter;\n    const timer = getTimerByIndex(timerIndex);\n\n    if (!timer) {\n        return;\n    }\n\n    if (reset) {\n        await timer.reset();\n    }\n\n    adapter.setStateChanged(`${timerIndex}.alive`, timer.isActive, true);\n    const {\n        hours,\n        minutes,\n        seconds,\n        stringTimer1,\n        stringTimer2,\n        startTimeString,\n        endTimeString,\n        inputDevice,\n        lengthTimer,\n        percent,\n        percent2,\n        initialTimer,\n    } = timer.getOutputProperties();\n    adapter.setStateChanged(`${timerIndex}.hour`, hours, true);\n    adapter.setStateChanged(`${timerIndex}.minute`, minutes, true);\n    adapter.setStateChanged(`${timerIndex}.second`, seconds, true);\n    adapter.setStateChanged(`${timerIndex}.string`, stringTimer1, true);\n    adapter.setStateChanged(`${timerIndex}.string_2`, stringTimer2, true);\n    adapter.setStateChanged(`${timerIndex}.TimeStart`, startTimeString, true);\n    adapter.setStateChanged(`${timerIndex}.TimeEnd`, endTimeString, true);\n    adapter.setStateChanged(`${timerIndex}.InputDeviceName`, inputDevice, true);\n    adapter.setStateChanged(`${timerIndex}.lengthTimer`, lengthTimer, true);\n    adapter.setStateChanged(`${timerIndex}.percent2`, percent2, true);\n    adapter.setStateChanged(`${timerIndex}.percent`, percent, true);\n    adapter.setStateChanged(`${timerIndex}.initialTimer`, initialTimer, true);\n    adapter.setStateChanged(`${timerIndex}.name`, timer.outPutTimerName(), true);\n    adapter.setStateChanged(`${timerIndex}.json`, timer.isActive ? timer.getDataAsJson() : '{}', true);\n    adapter.setStateChanged('all_Timer.alive', !reset, true);\n};\n\nexport async function writeStates({ reset }: { reset: boolean }): Promise<void> {\n    try {\n        for (const timerIndex in timerObject.timerActive.timer) {\n            await writeStatesByTimerIndex(timerIndex, reset);\n        }\n    } catch (e: any) {\n        errorLogger('Error in writeState', e, null);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAA4B;AAC5B,qBAA4B;AAC5B,mBAAkB;AAClB,mBAAgC;AAEzB,MAAM,0BAA0B,OAAO,YAAoB,UAAkC;AAChG,QAAM,UAAU,aAAAA,QAAM;AACtB,QAAM,YAAQ,8BAAgB,UAAU;AAExC,MAAI,CAAC,OAAO;AACR;AAAA,EACJ;AAEA,MAAI,OAAO;AACP,UAAM,MAAM,MAAM;AAAA,EACtB;AAEA,UAAQ,gBAAgB,GAAG,UAAU,UAAU,MAAM,UAAU,IAAI;AACnE,QAAM;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,IAAI,MAAM,oBAAoB;AAC9B,UAAQ,gBAAgB,GAAG,UAAU,SAAS,OAAO,IAAI;AACzD,UAAQ,gBAAgB,GAAG,UAAU,WAAW,SAAS,IAAI;AAC7D,UAAQ,gBAAgB,GAAG,UAAU,WAAW,SAAS,IAAI;AAC7D,UAAQ,gBAAgB,GAAG,UAAU,WAAW,cAAc,IAAI;AAClE,UAAQ,gBAAgB,GAAG,UAAU,aAAa,cAAc,IAAI;AACpE,UAAQ,gBAAgB,GAAG,UAAU,cAAc,iBAAiB,IAAI;AACxE,UAAQ,gBAAgB,GAAG,UAAU,YAAY,eAAe,IAAI;AACpE,UAAQ,gBAAgB,GAAG,UAAU,oBAAoB,aAAa,IAAI;AAC1E,UAAQ,gBAAgB,GAAG,UAAU,gBAAgB,aAAa,IAAI;AACtE,UAAQ,gBAAgB,GAAG,UAAU,aAAa,UAAU,IAAI;AAChE,UAAQ,gBAAgB,GAAG,UAAU,YAAY,SAAS,IAAI;AAC9D,UAAQ,gBAAgB,GAAG,UAAU,iBAAiB,cAAc,IAAI;AACxE,UAAQ,gBAAgB,GAAG,UAAU,SAAS,MAAM,gBAAgB,GAAG,IAAI;AAC3E,UAAQ,gBAAgB,GAAG,UAAU,SAAS,MAAM,WAAW,MAAM,cAAc,IAAI,MAAM,IAAI;AACjG,UAAQ,gBAAgB,mBAAmB,CAAC,OAAO,IAAI;AAC3D;AAEA,eAAsB,YAAY,EAAE,MAAM,GAAsC;AAC5E,MAAI;AACA,eAAW,cAAc,8BAAY,YAAY,OAAO;AACpD,YAAM,wBAAwB,YAAY,KAAK;AAAA,IACnD;AAAA,EACJ,SAAS,GAAQ;AACb,oCAAY,uBAAuB,GAAG,IAAI;AAAA,EAC9C;AACJ;",
  "names": ["store"]
}
