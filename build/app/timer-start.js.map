{
  "version": 3,
  "sources": ["../../src/app/timer-start.ts"],
  "sourcesContent": ["import type { TimerIndex } from '@/types/types';\nimport { timerObject } from '@/config/timer-data';\nimport store from '@/store/store';\nimport { interval } from '@/app/interval';\nimport { errorLogger } from '@/lib/logging';\nimport { isMoreThanAMinute, secToHourMinSec, timeToString } from '@/lib/time';\nimport { getParsedAlexaJson } from '@/app/ioBrokerStateAndObjects';\n\nexport const startTimer = async (sec: number, name: string): Promise<void> => {\n    try {\n        const timerIndex = getAvailableTimerIndex();\n        timerObject.timerActive.timer[timerIndex] = true;\n\n        const alexaJson = await getParsedAlexaJson();\n        if (!alexaJson) {\n            return;\n        }\n\n        const creationTime = alexaJson.creationTime;\n        const startTimeString = timeToString(creationTime);\n        const timerMilliseconds = sec * 1000;\n        const endTimeNumber = creationTime + timerMilliseconds;\n        const endTimeString = timeToString(endTimeNumber);\n        const timer = timerObject.timer[timerIndex];\n        const result = secToHourMinSec(sec, true);\n        await timer.init({\n            timerIndex,\n            creationTime,\n            startTimeString,\n            endTimeNumber,\n            endTimeString,\n            initialTimerString: result.initialString,\n        });\n\n        if (isMoreThanAMinute(sec)) {\n            interval(sec, name, timer, store.intervalMore60 * 1000, false);\n            return;\n        }\n\n        timerObject.timer[timerIndex].setInterval(store.intervalLess60 * 1000);\n\n        interval(sec, name, timer, store.intervalLess60 * 1000, true);\n    } catch (e: any) {\n        errorLogger('Error in startTimer', e, null);\n    }\n};\n\nexport function getAvailableTimerIndex(): TimerIndex {\n    const keys = Object.keys(timerObject.timerActive.timer);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (!timerObject.timerActive.timer[key]) {\n            return key;\n        }\n    }\n    return `timer${keys.length + 1}`;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,wBAA4B;AAC5B,mBAAkB;AAClB,sBAAyB;AACzB,qBAA4B;AAC5B,kBAAiE;AACjE,qCAAmC;AAE5B,MAAM,aAAa,OAAO,KAAa,SAAgC;AAC1E,MAAI;AACA,UAAM,aAAa,uBAAuB;AAC1C,kCAAY,YAAY,MAAM,UAAU,IAAI;AAE5C,UAAM,YAAY,UAAM,mDAAmB;AAC3C,QAAI,CAAC,WAAW;AACZ;AAAA,IACJ;AAEA,UAAM,eAAe,UAAU;AAC/B,UAAM,sBAAkB,0BAAa,YAAY;AACjD,UAAM,oBAAoB,MAAM;AAChC,UAAM,gBAAgB,eAAe;AACrC,UAAM,oBAAgB,0BAAa,aAAa;AAChD,UAAM,QAAQ,8BAAY,MAAM,UAAU;AAC1C,UAAM,aAAS,6BAAgB,KAAK,IAAI;AACxC,UAAM,MAAM,KAAK;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,oBAAoB,OAAO;AAAA,IAC/B,CAAC;AAED,YAAI,+BAAkB,GAAG,GAAG;AACxB,oCAAS,KAAK,MAAM,OAAO,aAAAA,QAAM,iBAAiB,KAAM,KAAK;AAC7D;AAAA,IACJ;AAEA,kCAAY,MAAM,UAAU,EAAE,YAAY,aAAAA,QAAM,iBAAiB,GAAI;AAErE,kCAAS,KAAK,MAAM,OAAO,aAAAA,QAAM,iBAAiB,KAAM,IAAI;AAAA,EAChE,SAAS,GAAQ;AACb,oCAAY,uBAAuB,GAAG,IAAI;AAAA,EAC9C;AACJ;AAEO,SAAS,yBAAqC;AACjD,QAAM,OAAO,OAAO,KAAK,8BAAY,YAAY,KAAK;AACtD,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,UAAM,MAAM,KAAK,CAAC;AAElB,QAAI,CAAC,8BAAY,YAAY,MAAM,GAAG,GAAG;AACrC,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO,QAAQ,KAAK,SAAS,CAAC;AAClC;",
  "names": ["store"]
}
