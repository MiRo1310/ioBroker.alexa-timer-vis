{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["'use strict';\nimport * as utils from '@iobroker/adapter-core';\nimport { decomposeInputValue } from '@/app/decompose-input-value';\nimport { delTimer } from '@/app/delete-timer';\nimport {\n    doesAlexaSendAQuestion,\n    isAlexaSummaryStateChanged as isAlexaStateToListenToChanged,\n    isIobrokerValue,\n} from '@/lib/global';\nimport { errorLogger } from '@/lib/logging';\nimport { resetAllTimerValuesAndState } from '@/app/reset';\nimport { setAdapterStatusAndInitStateCreation } from '@/lib/set-adapter-status';\nimport { timerAdd } from '@/lib/timer-add';\nimport { timerObject } from '@/config/timer-data';\nimport { Timer } from '@/app/timer';\nimport store from '@/store/store';\nimport type { TimerCondition } from '@/types/types';\nimport { getAbortWord } from '@/app/abort';\nimport { timerDelete } from '@/lib/timer-delete';\nimport { extendOrShortTimer } from '@/lib/timer-extend-or-shorten';\nimport { writeState } from '@/app/write-state';\n\nlet timeout_1: ioBroker.Timeout | undefined;\nlet debounceTimeout: ioBroker.Timeout | undefined;\n\nexport default class AlexaTimerVis extends utils.Adapter {\n    private static instance: AlexaTimerVis;\n\n    /**\n     * @param [options] - See {@link\n     */\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'alexa-timer-vis',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        AlexaTimerVis.instance = this;\n    }\n\n    private async onReady(): Promise<void> {\n        if (this.adapterConfig && '_id' in this.adapterConfig) {\n            store.init({\n                adapter: this,\n                alexaTimerVisInstance: this.adapterConfig?._id.replace('system.adapter.', ''),\n                ...this.config,\n            });\n        } else {\n            return;\n        }\n\n        await this.setState('info.connection', false, true);\n        timerObject.timer.timer1 = new Timer({ store });\n        timerObject.timer.timer2 = new Timer({ store });\n        timerObject.timer.timer3 = new Timer({ store });\n        timerObject.timer.timer4 = new Timer({ store });\n\n        await setAdapterStatusAndInitStateCreation();\n        resetAllTimerValuesAndState();\n\n        let voiceInput: string;\n\n        this.on('stateChange', async (id, state) => {\n            try {\n                if (isAlexaStateToListenToChanged({ state: state, id: id }) && isTimerAction(state)) {\n                    this.log.debug('Alexa state changed');\n                    let doNothingByNotNotedElement = false; // Bestimmte Aufrufe d\u00FCrfen keine Aktion ausf\u00FChren, wenn mehrere Ger\u00E4te zuh\u00F6ren. #12 und #14 .\n                    if (isIobrokerValue(state)) {\n                        store.timerAction = state.val as TimerCondition;\n                    }\n\n                    const res = await this.getForeignStateAsync(store.pathAlexaSummary);\n                    if (isIobrokerValue(res)) {\n                        voiceInput = res?.val as string;\n                        this.log.debug(`VoiceInput: ${voiceInput}`);\n                    }\n                    const abortWord = getAbortWord(voiceInput);\n                    if (abortWord) {\n                        this.log.debug(`Found abort word: ${abortWord}`);\n                        return;\n                    }\n                    if (timerObject.timerActive.data.notNotedSentence.find(el => el === voiceInput)) {\n                        this.log.debug('NotNotedSentence found');\n                        doNothingByNotNotedElement = true;\n                    }\n\n                    if (!doNothingByNotNotedElement || store.isDeleteTimer()) {\n                        const { name, timerSec, deleteVal } = decomposeInputValue(voiceInput);\n                        doesAlexaSendAQuestion(voiceInput);\n\n                        if (store.isDeleteTimer()) {\n                            await timerDelete(name, timerSec, voiceInput, deleteVal);\n                            return;\n                        }\n                        if (store.isAddTimer()) {\n                            timerAdd(name, timerSec);\n                            return;\n                        }\n                        if (store.isExtendTimer() || store.isShortenTimer()) {\n                            await extendOrShortTimer({ voiceInput, name });\n                            return;\n                        }\n                    }\n\n                    return;\n                }\n                if (isAlexaTimerVisResetButton(state, id)) {\n                    const timerIndex = id.split('.')[2];\n                    const timer = timerObject.timer[timerIndex];\n                    timer.stopTimerInAlexa();\n                    delTimer(timerIndex);\n                }\n            } catch (e) {\n                errorLogger('Error in stateChange', e);\n            }\n        });\n\n        this.subscribeForeignStates(store.pathAlexaStateToListenTo);\n    }\n\n    onUnload(callback: () => void): void {\n        try {\n            this.log.info('Adapter shuts down');\n\n            writeState({ reset: true }).catch((e: any) => {\n                errorLogger('Error in onUnload', e);\n            });\n\n            this.clearTimeout(timeout_1);\n            this.clearTimeout(debounceTimeout);\n\n            this.clearInterval(store.interval);\n\n            if (!timerObject.interval) {\n                return;\n            }\n\n            for (const element in timerObject.interval) {\n                this.clearInterval(timerObject.interval[element as keyof typeof timerObject.interval]);\n            }\n\n            this.log.debug('Intervals and timeouts cleared!');\n\n            callback();\n        } catch (e) {\n            errorLogger('Error in onUnload', e);\n            callback();\n        }\n    }\n}\n\nlet adapter;\nif (require.main !== module) {\n    adapter = (options: Partial<utils.AdapterOptions> | undefined): AlexaTimerVis => new AlexaTimerVis(options);\n} else {\n    (() => new AlexaTimerVis())();\n}\nexport { adapter };\n\nfunction isAlexaTimerVisResetButton(state: ioBroker.State | null | undefined, id: string): boolean {\n    return !!(isIobrokerValue(state) && state.val && id.includes('Reset'));\n}\n\nfunction isTimerAction(state: ioBroker.State | null | undefined): boolean {\n    if (!state?.val) {\n        return false;\n    }\n    return [\n        'SetNotificationIntent',\n        'ShortenNotificationIntent',\n        'ExtendNotificationIntent',\n        'RemoveNotificationIntent',\n    ].includes(state.val as string);\n}\n"],
  "mappings": "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",
  "names": ["store", "isAlexaStateToListenToChanged"]
}
