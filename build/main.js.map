{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["'use strict';\nimport * as utils from '@iobroker/adapter-core';\nimport { decomposeInputValue } from './lib/decompose-input-value';\nimport { delTimer, removeTimerInLastTimers as resetLastTimer } from './lib/delete-timer';\nimport {\n    doesAlexaSendAQuestion,\n    isAlexaSummaryStateChanged as isAlexaStateToListenToChanged,\n    isIobrokerValue,\n} from './lib/global';\nimport { errorLogger } from './lib/logging';\nimport { resetAllTimerValuesAndState } from './lib/reset';\nimport { setAdapterStatusAndInitStateCreation } from './lib/set-adapter-status';\nimport { timerAdd } from './lib/timer-add';\nimport { timerObject } from './config/timer-data';\nimport { timerDelete } from './lib/timer-delete';\nimport { extendOrShortTimer } from './lib/timer-extend-or-shorten';\nimport { getNewTimerName } from './lib/timer-name';\nimport { writeState } from './lib/write-state';\nimport type { Store, Timer, TimerCondition, Timers } from './types/types';\nimport { useStore } from './store/store';\nimport { getAbortWord } from './app/abort';\n\nlet timeout_1: ioBroker.Timeout | undefined;\nlet debounceTimeout: ioBroker.Timeout | undefined;\n\nexport default class AlexaTimerVis extends utils.Adapter {\n    private static instance: AlexaTimerVis;\n\n    /**\n     * @param [options] - See {@link\n     */\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'alexa-timer-vis',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        AlexaTimerVis.instance = this;\n    }\n\n    public static getInstance(): AlexaTimerVis {\n        return AlexaTimerVis.instance;\n    }\n\n    private async onReady(): Promise<void> {\n        const store = useStore();\n        store._this = this;\n\n        await this.setState('info.connection', false, true);\n        if (this.adapterConfig && '_id' in this.adapterConfig) {\n            store.alexaTimerVisInstance = this.adapterConfig?._id.replace('system.adapter.', '');\n        }\n\n        store.pathAlexaStateToListenTo = `${this.config.alexa}.History.intent`;\n        store.pathAlexaSummary = `${this.config.alexa}.History.summary`;\n\n        store.intervalMore60 = this.config.intervall1;\n        store.intervalLess60 = this.config.intervall2;\n\n        store.unitHour1 = this.config.unitHour1;\n        store.unitHour2 = this.config.unitHour2;\n        store.unitHour3 = this.config.unitHour3;\n        store.unitMinute1 = this.config.unitMinute1;\n        store.unitMinute2 = this.config.unitMinute2;\n        store.unitMinute3 = this.config.unitMinute3;\n        store.unitSecond1 = this.config.unitSecond1;\n        store.unitSecond3 = this.config.unitSecond3;\n        store.unitSecond2 = this.config.unitSecond2;\n\n        store.valHourForZero = this.config.valHourForZero;\n        store.valMinuteForZero = this.config.valMinuteForZero;\n        store.valSecondForZero = this.config.valSecondForZero;\n\n        store.debounceTime = this.config.entprellZeit;\n\n        await setAdapterStatusAndInitStateCreation();\n        resetAllTimerValuesAndState(this);\n\n        let voiceInput: string;\n\n        this.on('stateChange', async (id, state) => {\n            try {\n                await checkForTimerName(this, id);\n                if (isAlexaStateToListenToChanged({ state: state, id: id }) && isTimerAction(state)) {\n                    this.log.debug('Alexa state changed');\n                    let doNothingByNotNotedElement = false; // Bestimmte Aufrufe d\u00FCrfen keine Aktion ausf\u00FChren, wenn mehrere Ger\u00E4te zuh\u00F6ren. #12 und #14 .\n                    if (isIobrokerValue(state)) {\n                        store.timerAction = state.val as TimerCondition;\n                    }\n                    const res = await this.getForeignStateAsync(store.pathAlexaSummary);\n                    if (isIobrokerValue(res)) {\n                        voiceInput = res?.val as string;\n                        this.log.debug(`VoiceInput: ${voiceInput}`);\n                    }\n                    const abortWord = getAbortWord(voiceInput, this);\n                    if (abortWord) {\n                        this.log.debug(`Found abort word: ${abortWord}`);\n                        return;\n                    }\n                    if (timerObject.timerActive.data.notNotedSentence.find(el => el === voiceInput)) {\n                        this.log.debug('NotNotedSentence found');\n                        doNothingByNotNotedElement = true;\n                    }\n\n                    const {\n                        name: decomposeName,\n                        timerSec,\n                        deleteVal,\n                        inputString: decomposeInputString,\n                    } = decomposeInputValue(voiceInput);\n\n                    if (!doNothingByNotNotedElement || store.isDeleteTimer()) {\n                        doesAlexaSendAQuestion(voiceInput);\n\n                        if (store.isDeleteTimer()) {\n                            await timerDelete(decomposeName, timerSec, voiceInput, deleteVal);\n                            return;\n                        }\n                        if (store.isAddTimer()) {\n                            timerAdd(decomposeName, timerSec, decomposeInputString);\n                            return;\n                        }\n                        if (store.isExtendTimer() || store.isShortenTimer()) {\n                            await extendOrShortTimer({ voiceInput, decomposeName });\n                            return;\n                        }\n                    }\n\n                    return;\n                }\n                if (isAlexaTimerVisResetButton(state, id)) {\n                    const timer = id.split('.')[2] as keyof Timers;\n                    const timerObj = timerObject.timer[timer];\n\n                    this.setForeignState(\n                        getAlexaTextToCommandState(store, timerObj),\n                        buildTextCommand(timerObj),\n                        false,\n                    );\n                    delTimer(timer);\n                }\n\n                async function checkForTimerName(_this: AlexaTimerVis, id: string): Promise<void> {\n                    if (!isIobrokerValue(state) || state.val === '[]') {\n                        return;\n                    }\n                    const lastTimer = store.lastTimer;\n                    if (lastTimer.id === id) {\n                        resetLastTimer();\n\n                        getNewTimerName(state, lastTimer.timerSelector);\n                        await _this.unsubscribeForeignStatesAsync(id);\n                    }\n                }\n            } catch (e) {\n                errorLogger('Error in stateChange', e, this);\n            }\n        });\n\n        this.subscribeForeignStates(store.pathAlexaStateToListenTo);\n    }\n\n    onUnload(callback: () => void): void {\n        const store = useStore();\n        try {\n            this.log.info('Adapter shuts down');\n\n            writeState({ reset: true }).catch((e: any) => {\n                errorLogger('Error in onUnload', e, this);\n            });\n\n            this.clearTimeout(timeout_1);\n            this.clearTimeout(debounceTimeout);\n\n            this.clearInterval(store.interval);\n\n            if (!timerObject.interval) {\n                return;\n            }\n\n            for (const element in timerObject.interval) {\n                this.clearInterval(timerObject.interval[element as keyof typeof timerObject.interval]);\n            }\n\n            this.log.debug('Intervals and timeouts cleared!');\n\n            callback();\n        } catch (e) {\n            errorLogger('Error in onUnload', e, this);\n            callback();\n        }\n    }\n}\n\nlet adapter;\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    adapter = (options: Partial<utils.AdapterOptions> | undefined): AlexaTimerVis => new AlexaTimerVis(options);\n} else {\n    // otherwise start the instance directly\n    (() => new AlexaTimerVis())();\n}\nexport { adapter };\n\nfunction getAlexaTextToCommandState(store: Store, timerObj: Timer): string {\n    return `alexa2.${store.getAlexaInstanceObject().instance}.Echo-Devices.${timerObj.serialNumber}.Commands.textCommand`;\n}\n\nfunction isAlexaTimerVisResetButton(state: ioBroker.State | null | undefined, id: string): boolean {\n    return !!(isIobrokerValue(state) && state.val && id.includes('Reset'));\n}\n\nfunction buildTextCommand(timerOb: Timer): ioBroker.State | ioBroker.StateValue | ioBroker.SettableState {\n    return `stoppe ${timerOb.alexaTimerName && timerOb.alexaTimerName !== '' ? timerOb.alexaTimerName : timerOb.name !== 'Timer' ? timerOb.name.replace('Timer', '') : timerOb.inputString} Timer`;\n}\n\nfunction isTimerAction(state: ioBroker.State | null | undefined): boolean {\n    if (!state?.val) {\n        return false;\n    }\n    return [\n        'SetNotificationIntent',\n        'ShortenNotificationIntent',\n        'ExtendNotificationIntent',\n        'RemoveNotificationIntent',\n    ].includes(state.val as string);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,YAAuB;AACvB,mCAAoC;AACpC,0BAAoE;AACpE,oBAIO;AACP,qBAA4B;AAC5B,mBAA4C;AAC5C,gCAAqD;AACrD,uBAAyB;AACzB,wBAA4B;AAC5B,0BAA4B;AAC5B,qCAAmC;AACnC,wBAAgC;AAChC,yBAA2B;AAE3B,mBAAyB;AACzB,mBAA6B;AAE7B,IAAI;AACJ,IAAI;AAEJ,MAAO,sBAAoC,MAAM,QAAQ;AAAA,EACrD,OAAe;AAAA;AAAA;AAAA;AAAA,EAKR,YAAY,UAAyC,CAAC,GAAG;AAC5D,UAAM;AAAA,MACF,GAAG;AAAA,MACH,MAAM;AAAA,IACV,CAAC;AACD,SAAK,GAAG,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC;AACxC,SAAK,GAAG,UAAU,KAAK,SAAS,KAAK,IAAI,CAAC;AAC1C,kBAAc,WAAW;AAAA,EAC7B;AAAA,EAEA,OAAc,cAA6B;AACvC,WAAO,cAAc;AAAA,EACzB;AAAA,EAEA,MAAc,UAAyB;AA7C3C;AA8CQ,UAAM,YAAQ,uBAAS;AACvB,UAAM,QAAQ;AAEd,UAAM,KAAK,SAAS,mBAAmB,OAAO,IAAI;AAClD,QAAI,KAAK,iBAAiB,SAAS,KAAK,eAAe;AACnD,YAAM,yBAAwB,UAAK,kBAAL,mBAAoB,IAAI,QAAQ,mBAAmB;AAAA,IACrF;AAEA,UAAM,2BAA2B,GAAG,KAAK,OAAO,KAAK;AACrD,UAAM,mBAAmB,GAAG,KAAK,OAAO,KAAK;AAE7C,UAAM,iBAAiB,KAAK,OAAO;AACnC,UAAM,iBAAiB,KAAK,OAAO;AAEnC,UAAM,YAAY,KAAK,OAAO;AAC9B,UAAM,YAAY,KAAK,OAAO;AAC9B,UAAM,YAAY,KAAK,OAAO;AAC9B,UAAM,cAAc,KAAK,OAAO;AAChC,UAAM,cAAc,KAAK,OAAO;AAChC,UAAM,cAAc,KAAK,OAAO;AAChC,UAAM,cAAc,KAAK,OAAO;AAChC,UAAM,cAAc,KAAK,OAAO;AAChC,UAAM,cAAc,KAAK,OAAO;AAEhC,UAAM,iBAAiB,KAAK,OAAO;AACnC,UAAM,mBAAmB,KAAK,OAAO;AACrC,UAAM,mBAAmB,KAAK,OAAO;AAErC,UAAM,eAAe,KAAK,OAAO;AAEjC,cAAM,gEAAqC;AAC3C,kDAA4B,IAAI;AAEhC,QAAI;AAEJ,SAAK,GAAG,eAAe,OAAO,IAAI,UAAU;AACxC,UAAI;AACA,cAAM,kBAAkB,MAAM,EAAE;AAChC,gBAAI,cAAAA,4BAA8B,EAAE,OAAc,GAAO,CAAC,KAAK,cAAc,KAAK,GAAG;AACjF,eAAK,IAAI,MAAM,qBAAqB;AACpC,cAAI,6BAA6B;AACjC,kBAAI,+BAAgB,KAAK,GAAG;AACxB,kBAAM,cAAc,MAAM;AAAA,UAC9B;AACA,gBAAM,MAAM,MAAM,KAAK,qBAAqB,MAAM,gBAAgB;AAClE,kBAAI,+BAAgB,GAAG,GAAG;AACtB,yBAAa,2BAAK;AAClB,iBAAK,IAAI,MAAM,eAAe,UAAU,EAAE;AAAA,UAC9C;AACA,gBAAM,gBAAY,2BAAa,YAAY,IAAI;AAC/C,cAAI,WAAW;AACX,iBAAK,IAAI,MAAM,qBAAqB,SAAS,EAAE;AAC/C;AAAA,UACJ;AACA,cAAI,8BAAY,YAAY,KAAK,iBAAiB,KAAK,QAAM,OAAO,UAAU,GAAG;AAC7E,iBAAK,IAAI,MAAM,wBAAwB;AACvC,yCAA6B;AAAA,UACjC;AAEA,gBAAM;AAAA,YACF,MAAM;AAAA,YACN;AAAA,YACA;AAAA,YACA,aAAa;AAAA,UACjB,QAAI,kDAAoB,UAAU;AAElC,cAAI,CAAC,8BAA8B,MAAM,cAAc,GAAG;AACtD,sDAAuB,UAAU;AAEjC,gBAAI,MAAM,cAAc,GAAG;AACvB,wBAAM,iCAAY,eAAe,UAAU,YAAY,SAAS;AAChE;AAAA,YACJ;AACA,gBAAI,MAAM,WAAW,GAAG;AACpB,6CAAS,eAAe,UAAU,oBAAoB;AACtD;AAAA,YACJ;AACA,gBAAI,MAAM,cAAc,KAAK,MAAM,eAAe,GAAG;AACjD,wBAAM,mDAAmB,EAAE,YAAY,cAAc,CAAC;AACtD;AAAA,YACJ;AAAA,UACJ;AAEA;AAAA,QACJ;AACA,YAAI,2BAA2B,OAAO,EAAE,GAAG;AACvC,gBAAM,QAAQ,GAAG,MAAM,GAAG,EAAE,CAAC;AAC7B,gBAAM,WAAW,8BAAY,MAAM,KAAK;AAExC,eAAK;AAAA,YACD,2BAA2B,OAAO,QAAQ;AAAA,YAC1C,iBAAiB,QAAQ;AAAA,YACzB;AAAA,UACJ;AACA,4CAAS,KAAK;AAAA,QAClB;AAEA,uBAAe,kBAAkB,OAAsBC,KAA2B;AAC9E,cAAI,KAAC,+BAAgB,KAAK,KAAK,MAAM,QAAQ,MAAM;AAC/C;AAAA,UACJ;AACA,gBAAM,YAAY,MAAM;AACxB,cAAI,UAAU,OAAOA,KAAI;AACrB,oCAAAC,yBAAe;AAEf,mDAAgB,OAAO,UAAU,aAAa;AAC9C,kBAAM,MAAM,8BAA8BD,GAAE;AAAA,UAChD;AAAA,QACJ;AAAA,MACJ,SAAS,GAAG;AACR,wCAAY,wBAAwB,GAAG,IAAI;AAAA,MAC/C;AAAA,IACJ,CAAC;AAED,SAAK,uBAAuB,MAAM,wBAAwB;AAAA,EAC9D;AAAA,EAEA,SAAS,UAA4B;AACjC,UAAM,YAAQ,uBAAS;AACvB,QAAI;AACA,WAAK,IAAI,KAAK,oBAAoB;AAElC,yCAAW,EAAE,OAAO,KAAK,CAAC,EAAE,MAAM,CAAC,MAAW;AAC1C,wCAAY,qBAAqB,GAAG,IAAI;AAAA,MAC5C,CAAC;AAED,WAAK,aAAa,SAAS;AAC3B,WAAK,aAAa,eAAe;AAEjC,WAAK,cAAc,MAAM,QAAQ;AAEjC,UAAI,CAAC,8BAAY,UAAU;AACvB;AAAA,MACJ;AAEA,iBAAW,WAAW,8BAAY,UAAU;AACxC,aAAK,cAAc,8BAAY,SAAS,OAA4C,CAAC;AAAA,MACzF;AAEA,WAAK,IAAI,MAAM,iCAAiC;AAEhD,eAAS;AAAA,IACb,SAAS,GAAG;AACR,sCAAY,qBAAqB,GAAG,IAAI;AACxC,eAAS;AAAA,IACb;AAAA,EACJ;AACJ;AAEA,IAAI;AACJ,IAAI,QAAQ,SAAS,QAAQ;AAEzB,YAAU,CAAC,YAAsE,IAAI,cAAc,OAAO;AAC9G,OAAO;AAEH,GAAC,MAAM,IAAI,cAAc,GAAG;AAChC;AAGA,SAAS,2BAA2B,OAAc,UAAyB;AACvE,SAAO,UAAU,MAAM,uBAAuB,EAAE,QAAQ,iBAAiB,SAAS,YAAY;AAClG;AAEA,SAAS,2BAA2B,OAA0C,IAAqB;AAC/F,SAAO,CAAC,MAAE,+BAAgB,KAAK,KAAK,MAAM,OAAO,GAAG,SAAS,OAAO;AACxE;AAEA,SAAS,iBAAiB,SAA+E;AACrG,SAAO,UAAU,QAAQ,kBAAkB,QAAQ,mBAAmB,KAAK,QAAQ,iBAAiB,QAAQ,SAAS,UAAU,QAAQ,KAAK,QAAQ,SAAS,EAAE,IAAI,QAAQ,WAAW;AAC1L;AAEA,SAAS,cAAc,OAAmD;AACtE,MAAI,EAAC,+BAAO,MAAK;AACb,WAAO;AAAA,EACX;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,EAAE,SAAS,MAAM,GAAa;AAClC;",
  "names": ["isAlexaStateToListenToChanged", "id", "resetLastTimer"]
}
